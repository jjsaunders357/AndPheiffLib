package com.pheiffware.lib.examples.andGraphics;

import android.content.res.AssetManager;
import android.opengl.GLES20;

import com.pheiffware.lib.and.gui.graphics.openGL.SimpleGLRenderer;
import com.pheiffware.lib.fatalError.FatalErrorHandler;
import com.pheiffware.lib.geometry.Transform2D;
import com.pheiffware.lib.graphics.Camera;
import com.pheiffware.lib.graphics.GraphicsException;
import com.pheiffware.lib.graphics.Matrix3;
import com.pheiffware.lib.graphics.Matrix4;
import com.pheiffware.lib.graphics.managed.ManGL;
import com.pheiffware.lib.graphics.managed.Program;
import com.pheiffware.lib.graphics.managed.buffer.IndexBuffer;
import com.pheiffware.lib.graphics.managed.buffer.StaticVertexBuffer;
import com.pheiffware.lib.graphics.utils.PheiffGLUtils;

/**
 * A renderer which loads an object/program and then proceeds to render it over and over, while rotating the view.  This is used for examples.
 * <p/>
 * Created by Steve on 4/11/2016.
 */
public abstract class ExampleRotatingRenderer implements SimpleGLRenderer
{
    private static final double SCREEN_DRAG_TO_CAMERA_TRANSLATION = 0.01f;
    private ManGL manGL;
    private float rotation = 0;
    private Matrix4 translationMatrix;
    private Matrix3 normalMatrix = Matrix3.newZeroMatrix();
    private Camera camera = new Camera(90f, 1, 1, 100, false);
    private Program program;
    private IndexBuffer indexBuffer;
    private StaticVertexBuffer vertexBuffer;

    @Override
    public int maxMajorGLVersion()
    {
        return 3;
    }

    protected abstract Program loadProgram(AssetManager am, ManGL manGL) throws GraphicsException;

    protected abstract StaticVertexBuffer loadBuffers(AssetManager am, ManGL manGL, IndexBuffer indexBuffer, Program program) throws GraphicsException;

    protected abstract Matrix4 getTranslationMatrix();

    protected abstract void setUniforms(Program program, Matrix4 projectionMatrix, Matrix4 viewModelMatrix, Matrix3 normalMatrix);

    @Override
    public void onSurfaceCreated(AssetManager am, ManGL manGL)
    {
        try
        {
            this.manGL = manGL;
            FatalErrorHandler.installUncaughtExceptionHandler();
            GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
            GLES20.glClearDepthf(1);

            GLES20.glEnable(GLES20.GL_DEPTH_TEST);
            GLES20.glCullFace(GLES20.GL_BACK);
            GLES20.glEnable(GLES20.GL_CULL_FACE);


            program = loadProgram(am, manGL);
            indexBuffer = new IndexBuffer(false);
            vertexBuffer = loadBuffers(am, manGL, indexBuffer, program);
            translationMatrix = getTranslationMatrix();
            PheiffGLUtils.assertNoError();
        }
        catch (GraphicsException e)
        {
            FatalErrorHandler.handleFatalError(e);
        }
    }


    @Override
    public void onDrawFrame()
    {
        try
        {
            //Default view volume is based on sitting at origin and looking in negative z direction
            GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT | GLES20.GL_DEPTH_BUFFER_BIT);
            program.bind();

            Matrix4 modelMatrix = Matrix4.multiply(translationMatrix, Matrix4.newRotate(rotation, 1, 1, 0), Matrix4.newScale(1f, 2f, 1f));

            Matrix4 viewModelMatrix;
            viewModelMatrix = new Matrix4(camera.getCameraMatrix());
            viewModelMatrix.multiplyBy(modelMatrix);
            normalMatrix.setNormalTransformFromMatrix4Fast(viewModelMatrix);
            Matrix4 projectionMatrix = camera.getProjectionMatrix();

            setUniforms(program, projectionMatrix, viewModelMatrix, normalMatrix);
            vertexBuffer.bind();
            indexBuffer.drawAll(GLES20.GL_TRIANGLES);
            rotation++;
            PheiffGLUtils.assertNoError();
        }
        catch (GraphicsException e)
        {
            FatalErrorHandler.handleFatalError(e);
        }
    }


    @Override
    public void onSurfaceResize(int width, int height)
    {
        GLES20.glViewport(0, 0, width, height);
        camera.setAspect(width / (float) height);
    }

    /**
     * Must be called in renderer thread
     *
     * @param numPointers
     * @param transform   The transform generated by the last pointer motion event.
     */
    @Override
    public void touchTransformEvent(int numPointers, Transform2D transform)
    {
        if (numPointers > 2)
        {
            camera.zoom((float) transform.scale.x);
        }
        else if (numPointers > 1)
        {
            camera.roll((float) (180 * transform.rotation / Math.PI));
            camera.rotateScreenInputVector((float) transform.translation.x, (float) -transform.translation.y);
        }
        else
        {
            float cameraX = (float) (transform.translation.x * SCREEN_DRAG_TO_CAMERA_TRANSLATION);
            float cameraZ = (float) (transform.translation.y * SCREEN_DRAG_TO_CAMERA_TRANSLATION);
            camera.translateScreen(cameraX, 0, cameraZ);
        }
    }

}